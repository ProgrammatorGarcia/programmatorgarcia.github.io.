<!DOCTYPE html>
<html>
<title>
Search Algorithms Lecture 1
</title>

<body style="background-color: black;">
  <h1 style="color:white;">Logic & Computation Search Algorithms Lecture 1
    <div style="float: right;
    position: relative;
    top: 10px;
    right: 10px;">

      <img src="https://veritasprep.greatheartsamerica.org/wp-content/uploads/sites/16/2016/12/Veritas_crest_1C.png"
        width="150px" , height=" auto" />

    </div>
  </h1>
  <div style="font-family: monospace;
white-space: pre-wrap;
display: block;
color:white;
font-size: 25px;
text-align: justify;
">

import java.util.Scanner;
import java.util.Random;
import java.lang.System;

public class searchingAlgorithms {
    public static void main(String[] args) {

    //This new array will have 100,000 sorted elements from it, starting from 0 - 100,000 in order
    int[] intArr = newArray();

    int findIt = linearSearch(intArr, 50);



    }

    //Generates an array filled with 100,000 sorted elements from 0-100,000
    //For use in your homework if you want
    public static int[] newArray()
    {
        int[] arr = new int[100000];

        for(int i = 0; i < arr.length; i++)
        {
            arr[i] = i;
        }

        return arr;
    }

    //Linear search is a very basic searching algorithm.
    //It is merely a for loop that iterates each element in an array, from start to end
    //While it gets the job done, it's incredibly inefficient with a sorted array,
    //As it checks values that are redundant.

    //You could start in the middle of the array, and then compare if your middle value
    //Is greater or lesser than your target, and then iterating to the left or right of the array
    //As values to the right are greater, and values to the left are lesser.

    //But what if we could use that same power of halving the amount of elements we have to check, per EVERY STEP
    public static int linearSearch(int[] arr, int searchedValue)
    {
        int left = 0, right = arr.length - 1;
        //This will come useful for binarySearch...
        int mid = left + (right - left) / 2;

        long start = System.nanoTime();

        if(arr[mid] > searchedValue)
        {
            //If your middle is larger than your target
            //Start your search at the beginning of the array, and stop at the middle.
            for(int i = 0; i < mid; i++)
            {
                if(arr[i] == searchedValue)
                {
                    System.out.println("Found it!");
                    //The variable end measures the time when the algorithm finds the target
                    //Then it compares the start of the time to the end of the time to figure out
                    //How much time passed
                    long end = System.nanoTime();
                    System.out.println("Time is: " + (end - start)/100000f);
                    return arr[i];
                }
            }
        }
        else
        {
            //Else, your middle is smaller or equal to your target
            //And your search will therefore start in the middle of the array for better efficiency :)
            for(int i = mid; i < arr.length; i++)
            {
                if(arr[i] == searchedValue)
                {
                    System.out.println("Found it!");
                    //The variable end measures the time when the algorithm finds the target
                    //Then it compares the start of the time to the end of the time to figure out
                    //How much time passed
                    long end = System.nanoTime();
                    System.out.println("Time is: " + (end - start)/100000f);
                    return arr[i];
                }
            }
        }

        

        System.out.println("Couldn't find it...");
        long end = System.nanoTime();
        System.out.println("Time is: " + (end - start)/100000f);
        return -1;
    }



    //binarySearch template

    //Binary search is a searching algorithm that utilizes a SORTED array to find its target.
    //Knowing that the array is sorted, one would know that at some index of the array, every value to the right of that index is greater than the current value,
    //And every value to the left is lesser. Meaning, if the value you are currently at is greater than the value you are trying to search for,
    //Then your value must be to the left of the array, as every value to the right would only be greater than the current value that you are at.
    //Binary search utilizes this law to great effect to search for values extremely quickly.

    //Binary search starts at the middle of every array, and compares the current value its at with the value it wants to find.
    //If the current value is greater than its target, then the algorithm dumps every value to the right of the array, and then searches the new "middle" of the array with the smaller values.
    //If the current value is lesser than its target, then the algorithm dumps every value to the left of the array.
    //Essentially, the algorithm "halves" the amount of elements in an array PER STEP
    //An array with 100,000 elements quickly becomes an array of 1,000 elements in merely 8 steps. 100 in 12 steps. 8 elements in 16.
    //Because of this, binarySearch has a Big(O) of O(Log2(n)), which is incredibly powerful.
    //An array of 1 BILLION elements can be solved in merely 30 steps by this algorithm.
    

    //The algorithm is incomplete, you will need to finish it for today's lesson. :)
    //I've given you a template to help you get started.
    //Your job is to implement the searching logic inside the while loop

    //Remember, you are comparing the "middle" of the array with your target

    //If your middle value is larger than your target, then change your right boundary to
    //the value left of your middle.

    //If your middle value is smaller than your target, then change your left boundary to
    //the value right of your middle.
    public static int binarySearch(int arr[], int x)
    {
        //Initialize your left and right boundaries for the array
        int left = 0, right = arr.length - 1;

        //Start timing the code
        long start = System.nanoTime();

        while (left <= right)
        {
            int m = left + (right - left) / 2;
 
            // Check if x is present at mid
            //If it is, then return the index of the value
            if(arr[m] == x)
            {
                long end = System.nanoTime();
                System.out.println("Time is: " + (end - start)/100000f);
                return m;
            }

 
            // If x greater, ignore left half

            if(arr[m] < x)
            {

            }
            
 
            // If x is smaller, ignore right half
            else
            {

            }
            
        }
 
        // If we reach here, then element was
        // not present
        long end = System.nanoTime();
        System.out.println("Time is: " + (end - start)/100000f);
        return -1;
    }



//Out of bounds, don't go past this bracket for your methods!!!
    
}



  </div>
</body>

</html>